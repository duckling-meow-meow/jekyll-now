---
layout: post
title: 算法的构建过程
---

## 是怎样的呢...

## 先考虑暴力解法

有的题目就不用想那么多，暴力就可以满足要求，比如下面这个题目：

### 最少操作次数

输入一个包含N（1<=N<=1000）个整数的数组A，1<=A[i]<=1000000，你的任务是通过下面两种操作，使数组中所有元素变成相同的。

对元素减一，如果变成零，从数组中删除该元素；

对元素加一。

请写一个程序，输出一个整数，表示你需要的最少操作次数。

示例：

输入：[2,2,3]

输出：1       //将3减1

### c++代码

```c++
#include<bits/stdc++.h>
using namespace std;

vector<int> seq;

int main() {
	int n;
	int ans=0;
	scanf("%d", &n);
	for (int i = 0; i < n; ++i) {
		int x;
		scanf("%d", &x);
		seq.push_back(x);
	}
	for (int i = 0; i < n; ++i) {
		ans += min(seq[i], abs(seq[i] - seq[0]));
	}
	for (int i = 1; i < n; ++i) {
		int sum = 0;
		for (int j = 0; j < n; ++j) {
			sum += min(seq[j], abs(seq[j] - seq[i]));
		}
		ans = min(ans, sum);
	}
	printf("%d\n", ans);
	return 0;
}
```

这道题目的N很小，就是暴力题目，但是因为编程经验少，一上来就用了很长的时间想复杂的解法，而且都不好实现，会有各种漏洞。**所以一定要记住，对一个题目，尤其是这种N很小的，先考虑暴力解法！**

## 还是先考虑暴力解法

哈哈，就算一道题目的N很大，显然不能用暴力解法AC，**但是最好还是从暴力解法开始，然后观察暴力解法为什么暴力（哪些操作是多余的）**，想办法省掉这些操作就是**构建更好算法的过程和方法**啦！
